use std::string::String;
use serde_json::{Map, Value};

use crate::defs;

pub(crate) fn process_req(req: Map<String, Value>) -> (String, String) {
    // Перед считыванием значения по ключу обязательно проверять, что пара с желаемым ключом есть в структуре, чтобы не было вылета
    /* // шаблонные примеры - как считывать значения пар "ключ:значение"
    if req.contains_key("sat") {
        println!("sat: {}", req["sat"]);
    }
    if req.contains_key("action") {
        println!("action: {}", req["action"]);
    }*/
    // TODO: По результатам чтения и обработки req_map и выполнения в результате каких-то действий - возвратить две строки:
    //       status_line (заголовок - статус ответа HTTP) и contents (тело ответа)
    // TODO: здесь будет всякая обработка, переход из состояния в состояние, запись и чтение файла/бд
    //       (необходимо будет применять match к значениям в req, чтобы принимать решения)
    let mut s: &str = ""; // статус HTTP-ответа
    let mut c: &str = ""; // тело HTTP-ответа
    if req.contains_key("action") {
        // sat - токен
        if req.contains_key("sat") {
            // TODO: найти в таблице Auth запись с таким токеном, получить соответствующий uid
            //let uid = ... получить uid из записи с токеном, чтобы дальше сверяться с записями в User
            //       проверить ряд условий, чтобы определить, разрешено ли этому пользователю совершать действие action
            // Вот такой пример обработки множественных вариантов значений через match:
            (s, c) = match req["action"].as_str() {
                Some("create_group") => (defs::HTTP_STATUS_403, "{\"error\":\"Запрещено\"}"), //FIXME: заглушка
                _ => (defs::HTTP_STATUS_400, "{\"error\":\"Неподдерживаемая, невыполнимая или неверно сформированная операция\"}")
            };
        } else {
            if req["action"] == "login" {
                // TODO: проверить логин и пароль
                //       должно быть наличие id пользователя req["uid"] и пароля req["password"]
                //       uid - число, password - непустая строка
                //       и должна быть в бд/файле запись в таблице User с парой id-пароль, совпадающей с переданными uid и password
                //       (для пароля проверяется совпадение хэша переданной строки password с хранимым хэшем password в записи в таблице User)
                //       Если что-то не существует или не в соответствующем формате, то
                //return (defs::HTTP_STATUS_401.to_string(), "Неверный или некорректно сформированный id пользователя и/или пароль".to_string());
                //       Иначе (если все ок) - сформировать уникальный токен
                //                             создать новую запись в таблице Auth с переданным uid и сформированным токеном token
                //                             отдать token клиенту
                //return (defs::HTTP_STATUS_200.to_string(), token);
                (s, c) = (defs::HTTP_STATUS_200, "{\"token\":\"testtoken12345\"}"); // FIXME: заглушка

            } else {
                (s, c) = (defs::HTTP_STATUS_403, "{\"error\":\"Действие запрещено неавторизованным клиентам или не поддерживается\"}");
            }
        }
    } else {
        (s, c) = (defs::HTTP_STATUS_400, "{\"error\":\"Действие не задано\"}");
    }
    return (s.to_string(), c.to_string());
}